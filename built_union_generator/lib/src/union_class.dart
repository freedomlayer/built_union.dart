import 'union_spec.dart';

/// Generate union type enum code
/// Example:
/// ```
/// enum _$SimpleUnionType {
///   empty,
///   integer,
///   tuple,
///   string,
///   fooInt,
///   fooString,
/// }
/// ```
String generateEnumType(UnionSpec unionSpec) {
  List<String> res = [];
  res.add('enum ${calcEnumName(unionSpec)} {');
  for (final variant in unionSpec.variants) {
    res.add('\t${variant.variantName},');
  }
  res.add('}');
  return res.join('\n');
}

/// Generate a class constructor.
/// Example:
/// ```
/// _$SimpleUnion.integer(int integer)
///     : _type = _$SimpleUnionType.integer,
///       assert(integer != null,
///           '_$SimpleUnion constructor argument integer can not be null!'),
///       _values = [integer];
/// ```
String generateClassConstructor(
    String className, String enumName, VariantSpec variant) {
  List<String> res = [];

  // Constructor name:
  res.add('$className.${variant.variantName}(');

  // Add List of arguments:
  List<String> args = [];
  for (final argSpec in variant.variantArgs) {
    args.add('${argSpec.argType.toString()} ${argSpec.argName}');
  }
  res.add(args.join(','));
  res.add('): ');

  // Set type:
  res.add('_type = $enumName.${variant.variantName}, ');

  // Set values:
  res.add('_values = [');

  // Collect all values:
  List<String> values = [];
  for (final argSpec in variant.variantArgs) {
    values.add(argSpec.argName);
  }

  // Add values:
  res.add(values.join(','));

  // Close values:
  res.add('];');

  return res.join('');
}

/// Generate list of constructors for the base autogenerated class
/// Example:
/// ```
/// _$SimpleUnion.empty()
///     : _type = _$SimpleUnionType.empty,
///       _values = [];
/// _$SimpleUnion.integer(int integer)
///     : _type = _$SimpleUnionType.integer,
///       assert(integer != null,
///           '_$SimpleUnion constructor argument integer can not be null!'),
///       _values = [integer];
/// _$SimpleUnion.tuple(int tupleInt, String tupleString)
///     : _type = _$SimpleUnionType.tuple,
///       assert(tupleInt != null,
///           '_$SimpleUnion constructor argument tupleInt can not be null!'),
///       assert(tupleString != null,
///           '_$SimpleUnion constructor argument tupleString can not be null!'),
///       _values = [tupleInt, tupleString];
/// _$SimpleUnion.string(String string)
///     : _type = _$SimpleUnionType.string,
///       assert(string != null,
///           '_$SimpleUnion constructor argument string can not be null!'),
///       _values = [string];
/// _$SimpleUnion.builtList(BuiltList<int> builtList)
///     : _type = _$SimpleUnionType.builtList,
///       assert(builtList != null,
///           '_$SimpleUnion constructor argument builtList can not be null!'),
///       _values = [builtList];
/// ```

String generateClassConstructors(UnionSpec unionSpec) {
  List<String> res = [];

  for (final variant in unionSpec.variants) {
    res.add(generateClassConstructor(
        calcClassName(unionSpec), calcEnumName(unionSpec), variant));
  }
  return res.join('\n');
}

/// Generate one match argument
/// Example:
/// ```
/// required T Function(int, String) tuple,
/// ```
String generateMatchArg(VariantSpec variantSpec) {
  List<String> argTypes = [];
  for (final arg in variantSpec.variantArgs) {
    argTypes.add(arg.argType.toString());
  }
  return 'required T Function(${argTypes.join(',')}) ${variantSpec.variantName}';
}

/// Generate one match body switch case
/// Example:
/// ```
/// case _$SimpleUnionType.tuple:
///   return tuple(_values[0], _values[1]);
/// ```
String generateMatchCase(String enumName, VariantSpec variantSpec) {
  List<String> res = [];

  res.add('case $enumName.${variantSpec.variantName}:');

  List<String> values = [];
  for (var i = 0; i < variantSpec.variantArgs.length; ++i) {
    values
        .add('_values[$i] as ${variantSpec.variantArgs[i].argType.toString()}');
  }

  res.add('\treturn ${variantSpec.variantName}(${values.join(',')});');

  return res.join('\n');
}

/// Generate a match method
/// Example:
/// ```
/// T match<T>({
///   required T Function() empty,
///   required T Function(int) integer,
///   required T Function(int, String) tuple,
///   required T Function(String) string,
///   required T Function(Foo<int>) fooInt,
///   required T Function(Foo<String>) fooString,
/// }) {
///   switch (_type) {
///     case _$SimpleUnionType.empty:
///       return empty();
///     case _$SimpleUnionType.integer:
///       return integer(_values[0] as int);
///     case _$SimpleUnionType.tuple:
///       return tuple(_values[0] as int, _values[1] as String);
///     case _$SimpleUnionType.string:
///       return string(_values[0] as String);
///     case _$SimpleUnionType.fooInt:
///       return fooInt(_values[0] as Foo<int>);
///     case _$SimpleUnionType.fooString:
///       return fooString(_values[0] as Foo<String>);
///     default:
///       throw StateError('unknown type');
///   }
/// }
/// ```
String generateMatch(UnionSpec unionSpec) {
  List<String> res = [];

  // Begin match declaration:
  res.add('T match<T>({');

  // match arguments:
  List<String> matchArgs = [];
  for (final variant in unionSpec.variants) {
    matchArgs.add(generateMatchArg(variant));
  }
  res.add(matchArgs.join(',\n'));

  // End match declaration and begin body:
  res.add('}) {');

  // Begin switch statement:
  res.add('switch (_type) {');

  // Add cases:
  for (final variant in unionSpec.variants) {
    res.add(generateMatchCase(calcEnumName(unionSpec), variant));
  }

  // Default case:
  res.add('default:');

  // TODO: Possibly get a better exception here?
  res.add('''throw StateError('${unionSpec.unionName}: Unknown type');''');

  // End switch statement:
  res.add('}');

  // End match body:
  res.add('}');

  return res.join('\n');
}

/// Change first letter of a string to be upper case
String capitalize(String inputStr) {
  if (inputStr.isEmpty) {
    return inputStr;
  } else {
    return inputStr[0].toUpperCase() + inputStr.substring(1);
  }
}

/// Generate a single ergonomic "Is" getter
/// Example:
/// ```
/// bool get isEmpty => _type == _$SimpleUnionType.empty;
/// ```
String generateIsGetter(String enumName, VariantSpec variantSpec) {
  final isMethodName = 'is' + capitalize(variantSpec.variantName);
  return 'bool get $isMethodName => _type == $enumName.${variantSpec.variantName};';
}

/// Generate ergonomic "Is" getters code.
/// Example:
/// ```
/// bool get isEmpty => _type == _$SimpleUnionType.empty;
/// bool get isInteger => _type == _$SimpleUnionType.integer;
/// bool get isTuple => _type == _$SimpleUnionType.tuple;
/// bool get isString => _type == _$SimpleUnionType.string;
/// bool get isListInt => _type == _$SimpleUnionType.listInt;
/// ```
String generateIsGetters(UnionSpec unionSpec) {
  List<String> res = [];
  final enumName = calcEnumName(unionSpec);
  for (final variant in unionSpec.variants) {
    res.add(generateIsGetter(enumName, variant));
  }
  return res.join('\n');
}

/// Generate the equality operator for the autogenerated class.
String generateEqualOperator(String className) {
  return '''
  @override
  bool operator ==(Object other) {
    if (identical(other, this)) {
      return true;
    }
    if (other is $className) {
      if (_type != other._type) {
        return false;
      }
      if (_values.length != other._values.length) {
        return false;
      }
      for (var i=0; i < _values.length; ++i) {
        if (_values[i] != other._values[i]) {
          return false;
        }
      }
      return true;
    } else {
      return false;
    }
  }
  ''';
}

/// A hashCode() implementation for the autogenerated class
String generateHashCode() {
  return '''
  @override
  int get hashCode {
    var curVal = \$jc(0, _type.hashCode);
    for (final value in _values) {
      curVal = \$jc(curVal, value.hashCode);
    }

    return \$jf(curVal);
  }
  ''';
}

// TODO: Check if this function gives the wanted string result?
/// A toString() implementation for the autogenerated class
String generateToString(String userClassName) {
  return '''
  @override toString() {
    final variantStr = '\$_type'.split('.')[1];
    final valuesStr = _values.map((value) => '\$value').join(', ');
    return '$userClassName.\$variantStr(\$valuesStr)';
  }
  ''';
}

/*
  @override
  String toString() => (newBuiltValueToStringHelper('$userClassName')
        ..add('value', _values)
        ..add('type', _type))
      .toString();
  ''';
 */

/// Generate union base class
/// Example:
/// ```
/// abstract class _$SimpleUnion {
///   final _$SimpleUnionType _type;
///   final List<Object> _values;
///
///   // ... Constructors ...
///
///   // ... Match method ...
///
///   // ... ergonomic is getters ...
///
///   // ... Equal (==) operator
///
///   // ... hashCode() ...
///
///   // ... toString() ...
///
/// }
/// ```
String generateUnionClass(UnionSpec unionSpec) {
  List<String> res = [];

  // Class header:
  res.add('abstract class ${calcClassName(unionSpec)} {');

  // Class state: _type and _values:
  res.add('\tfinal ${calcEnumName(unionSpec)} _type;');
  res.add('\tfinal List<Object> _values;');

  res.add(generateClassConstructors(unionSpec));
  res.add(generateMatch(unionSpec));
  res.add(generateIsGetters(unionSpec));
  res.add(generateEqualOperator(calcClassName(unionSpec)));
  res.add(generateHashCode());
  res.add(generateToString(unionSpec.unionName));

  res.add('}');

  return res.join('\n');
}
